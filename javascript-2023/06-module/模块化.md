# 模块化

## 模块化的演变历程

**文件划分的方式**

```html
<script src="a.js"></script>
<script src="b.js"></script>
```

缺点：
- 污染全局变量
- 命名冲突
- 无法管理模块之间的依赖关系

**命名空间**

通过添加命名空间

```js
const moduleA = {
  name: 1
}

moduleA.name
```

**IIFE**

使用立即执行函数，私有成员通过闭包的方式访问

```js
(function($) {
  var name = ""

  window.moduleA = {
    exportName = '23'
  }
})(jQuery)
```

**CommonJs**

- 一个文件就是一个模块
- 每个模块都有单独的作用域
- 通过module.exports导出成员
- 通过require导入

commonjs是同步加载的，不适用于浏览器，因为会造成阻塞

**AMD**

因为浏览器不适合同步加载，所有有了AMD规范，而require.js实现了这个规范

```js
// 定义一个moduleA的模块
// 依赖了moduleB，moduleC
define('moduleA', ['moduleB', 'moduleC'], function($, modulec) {
  return {
    start: function() {
      modulec()
    }
  }
})
```

- AMD使用起来比较复杂
- 模块JS文件请求频繁

**CMD**

```js
define(function(require, exports, module) {
  var $ = require('jquery')
  module.exports = function() {
    console.log('module')
  }
})
```
